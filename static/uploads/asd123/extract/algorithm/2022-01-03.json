[
    {
        "type": "message",
        "subtype": "channel_join",
        "ts": "1641243042.000200",
        "user": "U02SFTK3961",
        "text": "<@U02SFTK3961> has joined the channel"
    },
    {
        "client_msg_id": "0e6b4f03-39e5-4c78-8946-c1426ece5739",
        "type": "message",
        "text": "<https:\/\/en.wikipedia.org\/wiki\/Breadth-first_search>",
        "user": "U02SFTK3961",
        "ts": "1641245756.000400",
        "team": "T02T8HEFFBJ",
        "user_team": "T02T8HEFFBJ",
        "source_team": "T02T8HEFFBJ",
        "user_profile": {
            "avatar_hash": "gac35da9856a",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/ac35da9856aaadd0feb146f212da19af.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png",
            "first_name": "mehmetcangun14",
            "real_name": "mehmetcangun14",
            "display_name": "",
            "team": "T02T8HEFFBJ",
            "name": "mehmetcangun14",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "image_url": "https:\/\/upload.wikimedia.org\/wikipedia\/commons\/thumb\/3\/33\/Breadth-first-tree.svg\/1200px-Breadth-first-tree.svg.png",
                "image_width": 1200,
                "image_height": 769,
                "image_bytes": 311509,
                "from_url": "https:\/\/en.wikipedia.org\/wiki\/Breadth-first_search",
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/wikipedia.png",
                "id": 1,
                "original_url": "https:\/\/en.wikipedia.org\/wiki\/Breadth-first_search",
                "fallback": "wikipedia: Breadth-first search",
                "text": "Breadth-first search (BFS) is an algorithm for searching a tree data structure for a node that satisfies a given property. It starts at the tree root and explores all nodes at the present depth prior to moving on to the nodes at the next depth level. Extra memory, usually a queue, is needed to keep track of the child nodes that were encountered but not yet explored. \nFor example, in a chess endgame a chess engine may build the game tree from the current position by applying all possible moves, and use breadth-first search to find a win position for white. Implicit trees (such as game trees or other problem-solving trees) may be of infinite size; breadth-first search is guaranteed to find a solution node if one exists.\nIn contrast, (plain) depth-first search, which explores the node branch as far as possible before backtracking and expanding other nodes, may get lost in an infinite branch and never make it to the solution node. Iterative deepening depth-first search avoids the latter drawback at the price of exploring the tree's top parts over and over again. On the other hand, both depth-first algorithms get along without extra memory.\nBreadth-first search can be generalized to graphs, when the start node (sometimes referred to as a 'search key') is explicitly given, and precautions are taken against following a vertex twice.\nBFS and its application in finding connected components of graphs were invented in 1945 by Konrad Zuse, in his (rejected) Ph.D. thesis on the Plankalkül programming language, but this was not published until 1972. It was reinvented in 1959 by Edward F. Moore, who used it to find the shortest path out of a maze, and later developed by C. Y. Lee into a wire routing algorithm (published 1961).",
                "title": "Breadth-first search",
                "title_link": "https:\/\/en.wikipedia.org\/wiki\/Breadth-first_search",
                "author_name": "Wikipedia",
                "author_link": "https:\/\/en.wikipedia.org\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "OyyM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https:\/\/en.wikipedia.org\/wiki\/Breadth-first_search"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "tada",
                "users": [
                    "U02SFTK3961"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "cc6864ac-3057-48d8-9645-0f8b0f394fb9",
        "type": "message",
        "text": "<https:\/\/en.wikipedia.org\/wiki\/A*_search_algorithm>",
        "user": "U02SFTK3961",
        "ts": "1641246055.000700",
        "team": "T02T8HEFFBJ",
        "user_team": "T02T8HEFFBJ",
        "source_team": "T02T8HEFFBJ",
        "user_profile": {
            "avatar_hash": "gac35da9856a",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/ac35da9856aaadd0feb146f212da19af.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png",
            "first_name": "mehmetcangun14",
            "real_name": "mehmetcangun14",
            "display_name": "",
            "team": "T02T8HEFFBJ",
            "name": "mehmetcangun14",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "image_url": "https:\/\/upload.wikimedia.org\/wikipedia\/commons\/6\/60\/A%2A_Search_Example_on_North_American_Freight_Train_Network.gif",
                "image_width": 554,
                "image_height": 306,
                "image_bytes": 391082,
                "from_url": "https:\/\/en.wikipedia.org\/wiki\/A*_search_algorithm",
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/wikipedia.png",
                "id": 1,
                "original_url": "https:\/\/en.wikipedia.org\/wiki\/A*_search_algorithm",
                "fallback": "wikipedia: A* search algorithm",
                "text": "A* (pronounced \"A-star\") is a graph traversal and path search algorithm, which is often used in many fields of computer science due to its completeness, optimality, and optimal efficiency. One major practical drawback is its \n  \n    \n      \n        O\n        (\n        \n          b\n          \n            d\n          \n        \n        )\n      \n    \n    {\\displaystyle O(b^{d})}\n   space complexity, as it stores all generated nodes in memory. Thus, in practical travel-routing systems, it is generally outperformed by algorithms which can pre-process the graph to attain better performance, as well as memory-bounded approaches; however, A* is still the best solution in many cases.Peter Hart, Nils Nilsson and Bertram Raphael of Stanford Research Institute (now SRI International) first published the algorithm in 1968. It can be seen as an extension of Dijkstra's algorithm. A* achieves better performance by using heuristics to guide its search.",
                "title": "A* search algorithm",
                "title_link": "https:\/\/en.wikipedia.org\/wiki\/A*_search_algorithm",
                "author_name": "Wikipedia",
                "author_link": "https:\/\/en.wikipedia.org\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iia",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https:\/\/en.wikipedia.org\/wiki\/A*_search_algorithm"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "U02SFTK3961"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "da21bb5b-7719-4fb4-a651-35a9641f46a9",
        "type": "message",
        "text": "<https:\/\/en.wikipedia.org\/wiki\/Topological_sorting>",
        "user": "U02SFTK3961",
        "ts": "1641246062.001000",
        "team": "T02T8HEFFBJ",
        "user_team": "T02T8HEFFBJ",
        "source_team": "T02T8HEFFBJ",
        "user_profile": {
            "avatar_hash": "gac35da9856a",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/ac35da9856aaadd0feb146f212da19af.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png",
            "first_name": "mehmetcangun14",
            "real_name": "mehmetcangun14",
            "display_name": "",
            "team": "T02T8HEFFBJ",
            "name": "mehmetcangun14",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "image_url": "https:\/\/upload.wikimedia.org\/wikipedia\/commons\/e\/e2\/Parallel_Topological_Sorting.gif",
                "image_width": 1200,
                "image_height": 750,
                "image_bytes": 2399822,
                "from_url": "https:\/\/en.wikipedia.org\/wiki\/Topological_sorting",
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/wikipedia.png",
                "id": 1,
                "original_url": "https:\/\/en.wikipedia.org\/wiki\/Topological_sorting",
                "fallback": "wikipedia: Topological sorting",
                "text": "In computer science, a topological sort or topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering. For instance, the vertices of the graph may represent tasks to be performed, and the edges may represent constraints that one task must be performed before another; in this application, a topological ordering is just a valid sequence for the tasks. Precisely, a topological sort is a graph traversal in which each node v is visited only after all its dependencies are visited. A topological ordering is possible if and only if the graph has no directed cycles, that is, if it is a directed acyclic graph (DAG). Any DAG has at least one topological ordering, and algorithms are known for constructing a topological ordering of any DAG in linear time. Topological sorting has many applications especially in ranking problems such as feedback arc set. Topological sorting is possible even when the DAG has disconnected components.",
                "title": "Topological sorting",
                "title_link": "https:\/\/en.wikipedia.org\/wiki\/Topological_sorting",
                "author_name": "Wikipedia",
                "author_link": "https:\/\/en.wikipedia.org\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "mcV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https:\/\/en.wikipedia.org\/wiki\/Topological_sorting"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "white_check_mark",
                "users": [
                    "U02SFTK3961"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "9ed3ebb0-0d2f-4933-ad17-47fca1d0ec52",
        "type": "message",
        "text": "• <https:\/\/en.wikipedia.org\/wiki\/K_shortest_path_routing|K shortest path routing>\n• <https:\/\/en.wikipedia.org\/wiki\/Karger%27s_algorithm|Karger's algorithm>\n• <https:\/\/en.wikipedia.org\/wiki\/KHOPCA_clustering_algorithm|KHOPCA clustering algorithm>\n• <https:\/\/en.wikipedia.org\/wiki\/Kleitman%E2%80%93Wang_algorithms|Kleitman–Wang algorithms>\n• <https:\/\/en.wikipedia.org\/wiki\/Knight%27s_tour|Knight's tour>\n• <https:\/\/en.wikipedia.org\/wiki\/Knowledge_graph_embedding|Knowledge graph embedding>\n• <https:\/\/en.wikipedia.org\/wiki\/Knuth%27s_Simpath_algorithm|Knuth's Simpath algorithm>\n• <https:\/\/en.wikipedia.org\/wiki\/Kosaraju%27s_algorithm|Kosaraju's algorithm>\n• <https:\/\/en.wikipedia.org\/wiki\/Kruskal%27s_algorithm|Kruskal's algorithm>",
        "user": "U02SFTK3961",
        "ts": "1641246104.001700",
        "team": "T02T8HEFFBJ",
        "user_team": "T02T8HEFFBJ",
        "source_team": "T02T8HEFFBJ",
        "user_profile": {
            "avatar_hash": "gac35da9856a",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/ac35da9856aaadd0feb146f212da19af.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0019-72.png",
            "first_name": "mehmetcangun14",
            "real_name": "mehmetcangun14",
            "display_name": "",
            "team": "T02T8HEFFBJ",
            "name": "mehmetcangun14",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "attachments": [
            {
                "image_url": "https:\/\/upload.wikimedia.org\/wikipedia\/commons\/6\/6b\/15-node_network_containing_a_combination_of_bi-directional_and_uni-directional_links.png",
                "image_width": 515,
                "image_height": 313,
                "image_bytes": 40856,
                "from_url": "https:\/\/en.wikipedia.org\/wiki\/K_shortest_path_routing",
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/wikipedia.png",
                "id": 1,
                "original_url": "https:\/\/en.wikipedia.org\/wiki\/K_shortest_path_routing",
                "fallback": "wikipedia: K shortest path routing",
                "text": "The k shortest path routing problem is a generalization of the shortest path routing problem in a given network. It asks not only about a shortest path but also about next k−1 shortest paths (which may be longer than the shortest path). A variation of the problem is the loopless k shortest paths.\nFinding k shortest paths is possible by extending Dijkstra algorithm or Bellman-Ford algorithm and extend them to find more than one path.",
                "title": "K shortest path routing",
                "title_link": "https:\/\/en.wikipedia.org\/wiki\/K_shortest_path_routing",
                "author_name": "Wikipedia",
                "author_link": "https:\/\/en.wikipedia.org\/"
            },
            {
                "image_url": "https:\/\/upload.wikimedia.org\/wikipedia\/commons\/thumb\/c\/c0\/Min_cut_example.svg\/1200px-Min_cut_example.svg.png",
                "image_width": 1200,
                "image_height": 933,
                "image_bytes": 85948,
                "from_url": "https:\/\/en.wikipedia.org\/wiki\/Karger%27s_algorithm",
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/wikipedia.png",
                "id": 2,
                "original_url": "https:\/\/en.wikipedia.org\/wiki\/Karger%27s_algorithm",
                "fallback": "wikipedia: Karger's algorithm",
                "text": "In computer science and graph theory, Karger's algorithm is a randomized algorithm to compute a minimum cut of a connected graph. It was invented by David Karger and first published in 1993.The idea of the algorithm is based on the concept of contraction of an edge \n  \n    \n      \n        (\n        u\n        ,\n        v\n        )\n      \n    \n    {\\displaystyle (u,v)}\n   in an undirected graph \n  \n    \n      \n        G\n        =\n        (\n        V\n        ,\n        E\n        )\n      \n    \n    {\\displaystyle G=(V,E)}\n  . Informally speaking, the contraction of an edge merges the nodes \n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n   and \n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n   into one, reducing the total number of nodes of the graph by one. All other edges connecting either \n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n   or \n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n   are \"reattached\" to the merged node, effectively producing a multigraph. Karger's basic algorithm iteratively contracts randomly chosen edges until only two nodes remain; those nodes represent a cut in the original graph. By iterating this basic algorithm a sufficient number of times, a minimum cut can be found with high probability.",
                "title": "Karger's algorithm",
                "title_link": "https:\/\/en.wikipedia.org\/wiki\/Karger%27s_algorithm",
                "author_name": "Wikipedia",
                "author_link": "https:\/\/en.wikipedia.org\/"
            },
            {
                "image_url": "https:\/\/upload.wikimedia.org\/wikipedia\/commons\/thumb\/a\/a5\/KHOPCA_3D_example_1.png\/1200px-KHOPCA_3D_example_1.png",
                "image_width": 1200,
                "image_height": 1200,
                "image_bytes": 174579,
                "from_url": "https:\/\/en.wikipedia.org\/wiki\/KHOPCA_clustering_algorithm",
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/wikipedia.png",
                "id": 3,
                "original_url": "https:\/\/en.wikipedia.org\/wiki\/KHOPCA_clustering_algorithm",
                "fallback": "wikipedia: KHOPCA clustering algorithm",
                "text": "KHOPCA is an adaptive clustering algorithm originally developed for dynamic networks. KHOPCA (\n  \n    \n      \n        k\n      \n    \n    {\\textstyle k}\n  -hop clustering algorithm) provides a fully distributed and localized approach to group elements such as nodes in a network according to their distance from each other. KHOPCA  operates proactively through a simple set of rules that defines clusters, which are optimal with respect to the applied distance function.\nKHOPCA's clustering process explicitly supports joining and leaving of nodes, which makes KHOPCA suitable for highly dynamic networks. However, it has been demonstrated that KHOPCA also performs in static networks.Besides applications in ad hoc and wireless sensor networks, KHOPCA can be used in localization and navigation problems, networked swarming, and real-time data clustering and analysis.",
                "title": "KHOPCA clustering algorithm",
                "title_link": "https:\/\/en.wikipedia.org\/wiki\/KHOPCA_clustering_algorithm",
                "author_name": "Wikipedia",
                "author_link": "https:\/\/en.wikipedia.org\/"
            },
            {
                "from_url": "https:\/\/en.wikipedia.org\/wiki\/Kleitman%E2%80%93Wang_algorithms",
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/wikipedia.png",
                "id": 4,
                "original_url": "https:\/\/en.wikipedia.org\/wiki\/Kleitman%E2%80%93Wang_algorithms",
                "fallback": "wikipedia: Kleitman–Wang algorithms",
                "text": "The Kleitman–Wang algorithms are two different algorithms in graph theory solving the digraph realization problem, i.e. the question if there exists for a finite list of nonnegative integer pairs a simple directed graph such that its degree sequence is exactly this list. For a positive answer the list of integer pairs is called digraphic. Both algorithms construct a special solution if one exists or prove that one cannot find a positive answer. These constructions are based on recursive algorithms. Kleitman and Wang  gave these algorithms in 1973.",
                "title": "Kleitman–Wang algorithms",
                "title_link": "https:\/\/en.wikipedia.org\/wiki\/Kleitman%E2%80%93Wang_algorithms",
                "author_name": "Wikipedia",
                "author_link": "https:\/\/en.wikipedia.org\/"
            },
            {
                "image_url": "https:\/\/upload.wikimedia.org\/wikipedia\/commons\/d\/da\/Knight%27s_tour_anim_2.gif",
                "image_width": 408,
                "image_height": 408,
                "image_bytes": 51088,
                "from_url": "https:\/\/en.wikipedia.org\/wiki\/Knight%27s_tour",
                "service_icon": "https:\/\/a.slack-edge.com\/80588\/img\/unfurl_icons\/wikipedia.png",
                "id": 5,
                "original_url": "https:\/\/en.wikipedia.org\/wiki\/Knight%27s_tour",
                "fallback": "wikipedia: Knight's tour",
                "text": "A knight's tour is a sequence of moves of a knight on a chessboard such that the knight visits every square exactly once. If the knight ends on a square that is one knight's move from the beginning square (so that it could tour the board again immediately, following the same path), the tour is closed; otherwise, it is open.The knight's tour problem is the mathematical problem of finding a knight's tour. Creating a program to find a knight's tour is a common problem given to computer science students. Variations of the knight's tour problem involve chessboards of different sizes than the usual 8 × 8, as well as irregular (non-rectangular) boards.",
                "title": "Knight's tour",
                "title_link": "https:\/\/en.wikipedia.org\/wiki\/Knight%27s_tour",
                "author_name": "Wikipedia",
                "author_link": "https:\/\/en.wikipedia.org\/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LTZkt",
                "elements": [
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "https:\/\/en.wikipedia.org\/wiki\/K_shortest_path_routing",
                                        "text": "K shortest path routing"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "https:\/\/en.wikipedia.org\/wiki\/Karger%27s_algorithm",
                                        "text": "Karger's algorithm"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "https:\/\/en.wikipedia.org\/wiki\/KHOPCA_clustering_algorithm",
                                        "text": "KHOPCA clustering algorithm"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "https:\/\/en.wikipedia.org\/wiki\/Kleitman%E2%80%93Wang_algorithms",
                                        "text": "Kleitman–Wang algorithms"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "https:\/\/en.wikipedia.org\/wiki\/Knight%27s_tour",
                                        "text": "Knight's tour"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "https:\/\/en.wikipedia.org\/wiki\/Knowledge_graph_embedding",
                                        "text": "Knowledge graph embedding"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "https:\/\/en.wikipedia.org\/wiki\/Knuth%27s_Simpath_algorithm",
                                        "text": "Knuth's Simpath algorithm"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "https:\/\/en.wikipedia.org\/wiki\/Kosaraju%27s_algorithm",
                                        "text": "Kosaraju's algorithm"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "https:\/\/en.wikipedia.org\/wiki\/Kruskal%27s_algorithm",
                                        "text": "Kruskal's algorithm"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    }
                ]
            }
        ]
    }
]